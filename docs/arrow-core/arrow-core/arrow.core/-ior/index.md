//[arrow-core](../../../index.md)/[arrow.core](../index.md)/[Ior](index.md)

# Ior

[common]\
sealed class [Ior](index.md)&lt;out [A](index.md), out [B](index.md)&gt;

Port of https://github.com/typelevel/cats/blob/v0.9.0/core/src/main/scala/cats/data/Ior.scala

Represents a right-biased disjunction that is either an A, or a B, or both an A and a B.

An instance of [Ior](index.md)<A,B> is one of:

<ul><li>[Ior.Left](-left/index.md)<A></li><li>[Ior.Right](-right/index.md)<B></li><li>[Ior.Both](-both/index.md)<A,B></li></ul>

[Ior](index.md)<A,B> is similar to [Either](../-either/index.md)<A,B>, except that it can represent the simultaneous presence of an A and a B. It is right-biased so methods such as map and flatMap operate on the B value. Some methods, like flatMap, handle the presence of two [Ior.Both](-both/index.md) values using a [Semigroup]&lt;A&gt;, while other methods, like [toEither], ignore the A` value in a Ior.Both Both.

[Ior](index.md)<A,B> is isomorphic to [Either](../-either/index.md)<[Either](../-either/index.md)<A,B>, [Pair](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/index.html)<A,B>>, but provides methods biased toward B values, regardless of whether the B values appear in a [Ior.Right](-right/index.md) or a [Ior.Both](-both/index.md). The isomorphic Either form can be accessed via the [unwrap](unwrap.md) method.

## Types

| Name | Summary |
|---|---|
| [Both](-both/index.md) | [common]<br>data class [Both](-both/index.md)&lt;out [A](-both/index.md), out [B](-both/index.md)&gt;(leftValue: [A](-both/index.md), rightValue: [B](-both/index.md)) : [Ior](index.md)&lt;[A](-both/index.md), [B](-both/index.md)&gt; |
| [Companion](-companion/index.md) | [common]<br>object [Companion](-companion/index.md) |
| [Left](-left/index.md) | [common]<br>data class [Left](-left/index.md)&lt;out [A](-left/index.md)&gt;(value: [A](-left/index.md)) : [Ior](index.md)&lt;[A](-left/index.md), [Nothing](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing/index.html)&gt; |
| [Right](-right/index.md) | [common]<br>data class [Right](-right/index.md)&lt;out [B](-right/index.md)&gt;(value: [B](-right/index.md)) : [Ior](index.md)&lt;[Nothing](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing/index.html), [B](-right/index.md)&gt; |

## Functions

| Name | Summary |
|---|---|
| [all](all.md) | [common]<br>inline fun [all](all.md)(predicate: ([B](index.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [bicrosswalk](bicrosswalk.md) | [common]<br>inline fun &lt;[C](bicrosswalk.md), [D](bicrosswalk.md)&gt; [bicrosswalk](bicrosswalk.md)(fa: ([A](index.md)) -&gt; [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[C](bicrosswalk.md)&gt;, fb: ([B](index.md)) -&gt; [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[D](bicrosswalk.md)&gt;): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Ior](index.md)&lt;[C](bicrosswalk.md), [D](bicrosswalk.md)&gt;&gt; |
| [bicrosswalkMap](bicrosswalk-map.md) | [common]<br>inline fun &lt;[C](bicrosswalk-map.md), [D](bicrosswalk-map.md), [K](bicrosswalk-map.md)&gt; [bicrosswalkMap](bicrosswalk-map.md)(fa: ([A](index.md)) -&gt; [Map](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)&lt;[K](bicrosswalk-map.md), [C](bicrosswalk-map.md)&gt;, fb: ([B](index.md)) -&gt; [Map](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)&lt;[K](bicrosswalk-map.md), [D](bicrosswalk-map.md)&gt;): [Map](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)&lt;[K](bicrosswalk-map.md), [Ior](index.md)&lt;[C](bicrosswalk-map.md), [D](bicrosswalk-map.md)&gt;&gt; |
| [bicrosswalkNull](bicrosswalk-null.md) | [common]<br>inline fun &lt;[C](bicrosswalk-null.md), [D](bicrosswalk-null.md)&gt; [bicrosswalkNull](bicrosswalk-null.md)(fa: ([A](index.md)) -&gt; [C](bicrosswalk-null.md)?, fb: ([B](index.md)) -&gt; [D](bicrosswalk-null.md)?): [Ior](index.md)&lt;[C](bicrosswalk-null.md), [D](bicrosswalk-null.md)&gt;? |
| [bifoldLeft](bifold-left.md) | [common]<br>inline fun &lt;[C](bifold-left.md)&gt; [bifoldLeft](bifold-left.md)(c: [C](bifold-left.md), f: ([C](bifold-left.md), [A](index.md)) -&gt; [C](bifold-left.md), g: ([C](bifold-left.md), [B](index.md)) -&gt; [C](bifold-left.md)): [C](bifold-left.md) |
| [bifoldMap](bifold-map.md) | [common]<br>inline fun &lt;[C](bifold-map.md)&gt; [bifoldMap](bifold-map.md)(MN: [Monoid](../../arrow.typeclasses/-monoid/index.md)&lt;[C](bifold-map.md)&gt;, f: ([A](index.md)) -&gt; [C](bifold-map.md), g: ([B](index.md)) -&gt; [C](bifold-map.md)): [C](bifold-map.md) |
| [bimap](bimap.md) | [common]<br>inline fun &lt;[C](bimap.md), [D](bimap.md)&gt; [bimap](bimap.md)(fa: ([A](index.md)) -&gt; [C](bimap.md), fb: ([B](index.md)) -&gt; [D](bimap.md)): [Ior](index.md)&lt;[C](bimap.md), [D](bimap.md)&gt;<br>Apply fa if this is a [Left](-left/index.md) or [Both](-both/index.md) to A and apply fb if this is [Right](-right/index.md) or [Both](-both/index.md) to B |
| [bitraverse](bitraverse.md) | [common]<br>inline fun &lt;[AA](bitraverse.md), [C](bitraverse.md)&gt; [bitraverse](bitraverse.md)(fa: ([A](index.md)) -&gt; [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[AA](bitraverse.md)&gt;, fb: ([B](index.md)) -&gt; [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[C](bitraverse.md)&gt;): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Ior](index.md)&lt;[AA](bitraverse.md), [C](bitraverse.md)&gt;&gt; |
| [bitraverseEither](bitraverse-either.md) | [common]<br>inline fun &lt;[AA](bitraverse-either.md), [C](bitraverse-either.md), [D](bitraverse-either.md)&gt; [bitraverseEither](bitraverse-either.md)(fa: ([A](index.md)) -&gt; [Either](../-either/index.md)&lt;[AA](bitraverse-either.md), [C](bitraverse-either.md)&gt;, fb: ([B](index.md)) -&gt; [Either](../-either/index.md)&lt;[AA](bitraverse-either.md), [D](bitraverse-either.md)&gt;): [Either](../-either/index.md)&lt;[AA](bitraverse-either.md), [Ior](index.md)&lt;[C](bitraverse-either.md), [D](bitraverse-either.md)&gt;&gt; |
| [bitraverseNullable](bitraverse-nullable.md) | [common]<br>inline fun &lt;[C](bitraverse-nullable.md), [D](bitraverse-nullable.md)&gt; [bitraverseNullable](bitraverse-nullable.md)(fa: ([A](index.md)) -&gt; [C](bitraverse-nullable.md)?, fb: ([B](index.md)) -&gt; [D](bitraverse-nullable.md)?): [Ior](index.md)&lt;[C](bitraverse-nullable.md), [D](bitraverse-nullable.md)&gt;? |
| [bitraverseOption](bitraverse-option.md) | [common]<br>inline fun &lt;[C](bitraverse-option.md), [D](bitraverse-option.md)&gt; [bitraverseOption](bitraverse-option.md)(fa: ([A](index.md)) -&gt; [Option](../-option/index.md)&lt;[C](bitraverse-option.md)&gt;, fb: ([B](index.md)) -&gt; [Option](../-option/index.md)&lt;[D](bitraverse-option.md)&gt;): [Option](../-option/index.md)&lt;[Ior](index.md)&lt;[C](bitraverse-option.md), [D](bitraverse-option.md)&gt;&gt; |
| [bitraverseValidated](bitraverse-validated.md) | [common]<br>inline fun &lt;[AA](bitraverse-validated.md), [C](bitraverse-validated.md), [D](bitraverse-validated.md)&gt; [bitraverseValidated](bitraverse-validated.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[AA](bitraverse-validated.md)&gt;, fa: ([A](index.md)) -&gt; [Validated](../-validated/index.md)&lt;[AA](bitraverse-validated.md), [C](bitraverse-validated.md)&gt;, fb: ([B](index.md)) -&gt; [Validated](../-validated/index.md)&lt;[AA](bitraverse-validated.md), [D](bitraverse-validated.md)&gt;): [Validated](../-validated/index.md)&lt;[AA](bitraverse-validated.md), [Ior](index.md)&lt;[C](bitraverse-validated.md), [D](bitraverse-validated.md)&gt;&gt; |
| [crosswalk](crosswalk.md) | [common]<br>inline fun &lt;[C](crosswalk.md)&gt; [crosswalk](crosswalk.md)(fa: ([B](index.md)) -&gt; [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[C](crosswalk.md)&gt;): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Ior](index.md)&lt;[A](index.md), [C](crosswalk.md)&gt;&gt; |
| [crosswalkMap](crosswalk-map.md) | [common]<br>inline fun &lt;[K](crosswalk-map.md), [V](crosswalk-map.md)&gt; [crosswalkMap](crosswalk-map.md)(fa: ([B](index.md)) -&gt; [Map](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)&lt;[K](crosswalk-map.md), [V](crosswalk-map.md)&gt;): [Map](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)&lt;[K](crosswalk-map.md), [Ior](index.md)&lt;[A](index.md), [V](crosswalk-map.md)&gt;&gt; |
| [crosswalkNull](crosswalk-null.md) | [common]<br>inline fun &lt;[A](crosswalk-null.md), [B](crosswalk-null.md), [C](crosswalk-null.md)&gt; [crosswalkNull](crosswalk-null.md)(ior: [Ior](index.md)&lt;[A](crosswalk-null.md), [B](crosswalk-null.md)&gt;, fa: ([B](crosswalk-null.md)) -&gt; [C](crosswalk-null.md)?): [Ior](index.md)&lt;[A](crosswalk-null.md), [C](crosswalk-null.md)&gt;? |
| [exists](exists.md) | [common]<br>inline fun [exists](exists.md)(predicate: ([B](index.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns false if [Left](-left/index.md) or returns the result of the application of the given predicate to the [Right](-right/index.md) value. |
| [findOrNull](find-or-null.md) | [common]<br>inline fun [findOrNull](find-or-null.md)(predicate: ([B](index.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [B](index.md)? |
| [fold](fold.md) | [common]<br>inline fun &lt;[C](fold.md)&gt; [fold](fold.md)(fa: ([A](index.md)) -&gt; [C](fold.md), fb: ([B](index.md)) -&gt; [C](fold.md), fab: ([A](index.md), [B](index.md)) -&gt; [C](fold.md)): [C](fold.md)<br>Applies fa if this is a [Left](-left/index.md), fb if this is a [Right](-right/index.md) or fab if this is a [Both](-both/index.md) |
| [foldLeft](fold-left.md) | [common]<br>inline fun &lt;[C](fold-left.md)&gt; [foldLeft](fold-left.md)(c: [C](fold-left.md), f: ([C](fold-left.md), [B](index.md)) -&gt; [C](fold-left.md)): [C](fold-left.md) |
| [foldMap](fold-map.md) | [common]<br>inline fun &lt;[C](fold-map.md)&gt; [foldMap](fold-map.md)(MN: [Monoid](../../arrow.typeclasses/-monoid/index.md)&lt;[C](fold-map.md)&gt;, f: ([B](index.md)) -&gt; [C](fold-map.md)): [C](fold-map.md) |
| [isEmpty](is-empty.md) | [common]<br>fun [isEmpty](is-empty.md)(): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [isNotEmpty](is-not-empty.md) | [common]<br>fun [isNotEmpty](is-not-empty.md)(): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [leftOrNull](left-or-null.md) | [common]<br>fun [leftOrNull](left-or-null.md)(): [A](index.md)?<br>Returns the [Left](-left/index.md) value or A if this is [Left](-left/index.md) or [Both](-both/index.md) and null if this is a [Right](-right/index.md). |
| [map](map.md) | [common]<br>inline fun &lt;[D](map.md)&gt; [map](map.md)(f: ([B](index.md)) -&gt; [D](map.md)): [Ior](index.md)&lt;[A](index.md), [D](map.md)&gt;<br>The given function is applied if this is a [Right](-right/index.md) or [Both](-both/index.md) to B. |
| [mapLeft](map-left.md) | [common]<br>inline fun &lt;[C](map-left.md)&gt; [mapLeft](map-left.md)(fa: ([A](index.md)) -&gt; [C](map-left.md)): [Ior](index.md)&lt;[C](map-left.md), [B](index.md)&gt;<br>The given function is applied if this is a [Left](-left/index.md) or [Both](-both/index.md) to A. |
| [orNull](or-null.md) | [common]<br>fun [orNull](or-null.md)(): [B](index.md)?<br>Returns the [Right](-right/index.md) value or B if this is [Right](-right/index.md) or [Both](-both/index.md) and null if this is a [Left](-left/index.md). |
| [padNull](pad-null.md) | [common]<br>fun [padNull](pad-null.md)(): [Pair](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/index.html)&lt;[A](index.md)?, [B](index.md)?&gt;<br>Return this [Ior](index.md) as [Pair](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/index.html) of nullables] |
| [swap](swap.md) | [common]<br>fun [swap](swap.md)(): [Ior](index.md)&lt;[B](index.md), [A](index.md)&gt;<br>If this is a [Left](-left/index.md), then return the left value in [Right](-right/index.md) or vice versa, when this is [Both](-both/index.md) , left and right values are swap |
| [toEither](to-either.md) | [common]<br>fun [toEither](to-either.md)(): [Either](../-either/index.md)&lt;[A](index.md), [B](index.md)&gt;<br>Returns a [Either.Right](../-either/-right/index.md) containing the [Right](-right/index.md) value or B if this is [Right](-right/index.md) or [Both](-both/index.md) and [Either.Left](../-either/-left/index.md) if this is a [Left](-left/index.md). |
| [toString](to-string.md) | [common]<br>open override fun [toString](to-string.md)(): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
| [toValidated](to-validated.md) | [common]<br>fun [toValidated](to-validated.md)(): [Validated](../-validated/index.md)&lt;[A](index.md), [B](index.md)&gt;<br>Returns a [Validated.Valid](../-validated/-valid/index.md) containing the [Right](-right/index.md) value or B if this is [Right](-right/index.md) or [Both](-both/index.md) and [Validated.Invalid](../-validated/-invalid/index.md) if this is a [Left](-left/index.md). |
| [traverse](traverse.md) | [common]<br>inline fun &lt;[C](traverse.md)&gt; [traverse](traverse.md)(fa: ([B](index.md)) -&gt; [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[C](traverse.md)&gt;): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Ior](index.md)&lt;[A](index.md), [C](traverse.md)&gt;&gt; |
| [traverseEither](traverse-either.md) | [common]<br>inline fun &lt;[AA](traverse-either.md), [C](traverse-either.md)&gt; [traverseEither](traverse-either.md)(fa: ([B](index.md)) -&gt; [Either](../-either/index.md)&lt;[AA](traverse-either.md), [C](traverse-either.md)&gt;): [Either](../-either/index.md)&lt;[AA](traverse-either.md), [Ior](index.md)&lt;[A](index.md), [C](traverse-either.md)&gt;&gt; |
| [traverseNullable](traverse-nullable.md) | [common]<br>inline fun &lt;[C](traverse-nullable.md)&gt; [traverseNullable](traverse-nullable.md)(fa: ([B](index.md)) -&gt; [C](traverse-nullable.md)?): [Ior](index.md)&lt;[A](index.md), [C](traverse-nullable.md)&gt;? |
| [traverseOption](traverse-option.md) | [common]<br>inline fun &lt;[C](traverse-option.md)&gt; [traverseOption](traverse-option.md)(fa: ([B](index.md)) -&gt; [Option](../-option/index.md)&lt;[C](traverse-option.md)&gt;): [Option](../-option/index.md)&lt;[Ior](index.md)&lt;[A](index.md), [C](traverse-option.md)&gt;&gt; |
| [traverseValidated](traverse-validated.md) | [common]<br>inline fun &lt;[AA](traverse-validated.md), [C](traverse-validated.md)&gt; [traverseValidated](traverse-validated.md)(fa: ([B](index.md)) -&gt; [Validated](../-validated/index.md)&lt;[AA](traverse-validated.md), [C](traverse-validated.md)&gt;): [Validated](../-validated/index.md)&lt;[AA](traverse-validated.md), [Ior](index.md)&lt;[A](index.md), [C](traverse-validated.md)&gt;&gt; |
| [unwrap](unwrap.md) | [common]<br>fun [unwrap](unwrap.md)(): [Either](../-either/index.md)&lt;[Either](../-either/index.md)&lt;[A](index.md), [B](index.md)&gt;, [Pair](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/index.html)&lt;[A](index.md), [B](index.md)&gt;&gt;<br>Return the isomorphic [Either](../-either/index.md) of this [Ior](index.md) |
| [void](void.md) | [common]<br>fun [void](void.md)(): [Ior](index.md)&lt;[A](index.md), [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)&gt; |

## Properties

| Name | Summary |
|---|---|
| [isBoth](is-both.md) | [common]<br>abstract val [isBoth](is-both.md): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if this is a [Both](-both/index.md), false otherwise. |
| [isLeft](is-left.md) | [common]<br>abstract val [isLeft](is-left.md): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if this is a [Left](-left/index.md), false otherwise. |
| [isRight](is-right.md) | [common]<br>abstract val [isRight](is-right.md): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if this is a [Right](-right/index.md), false otherwise. |

## Inheritors

| Name |
|---|
| [Ior](-left/index.md) |
| [Ior](-right/index.md) |
| [Ior](-both/index.md) |

## Extensions

| Name | Summary |
|---|---|
| [bisequence](../bisequence.md) | [common]<br>fun &lt;[A](../bisequence.md), [B](../bisequence.md)&gt; [Ior](index.md)&lt;[Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[A](../bisequence.md)&gt;, [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[B](../bisequence.md)&gt;&gt;.[bisequence](../bisequence.md)(): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Ior](index.md)&lt;[A](../bisequence.md), [B](../bisequence.md)&gt;&gt; |
| [bisequenceEither](../bisequence-either.md) | [common]<br>fun &lt;[A](../bisequence-either.md), [B](../bisequence-either.md), [C](../bisequence-either.md)&gt; [Ior](index.md)&lt;[Either](../-either/index.md)&lt;[A](../bisequence-either.md), [B](../bisequence-either.md)&gt;, [Either](../-either/index.md)&lt;[A](../bisequence-either.md), [C](../bisequence-either.md)&gt;&gt;.[bisequenceEither](../bisequence-either.md)(): [Either](../-either/index.md)&lt;[A](../bisequence-either.md), [Ior](index.md)&lt;[B](../bisequence-either.md), [C](../bisequence-either.md)&gt;&gt; |
| [bisequenceNullable](../bisequence-nullable.md) | [common]<br>fun &lt;[B](../bisequence-nullable.md), [C](../bisequence-nullable.md)&gt; [Ior](index.md)&lt;[B](../bisequence-nullable.md)?, [C](../bisequence-nullable.md)?&gt;.[bisequenceNullable](../bisequence-nullable.md)(): [Ior](index.md)&lt;[B](../bisequence-nullable.md), [C](../bisequence-nullable.md)&gt;? |
| [bisequenceOption](../bisequence-option.md) | [common]<br>fun &lt;[B](../bisequence-option.md), [C](../bisequence-option.md)&gt; [Ior](index.md)&lt;[Option](../-option/index.md)&lt;[B](../bisequence-option.md)&gt;, [Option](../-option/index.md)&lt;[C](../bisequence-option.md)&gt;&gt;.[bisequenceOption](../bisequence-option.md)(): [Option](../-option/index.md)&lt;[Ior](index.md)&lt;[B](../bisequence-option.md), [C](../bisequence-option.md)&gt;&gt; |
| [bisequenceValidated](../bisequence-validated.md) | [common]<br>fun &lt;[A](../bisequence-validated.md), [B](../bisequence-validated.md), [C](../bisequence-validated.md)&gt; [Ior](index.md)&lt;[Validated](../-validated/index.md)&lt;[A](../bisequence-validated.md), [B](../bisequence-validated.md)&gt;, [Validated](../-validated/index.md)&lt;[A](../bisequence-validated.md), [C](../bisequence-validated.md)&gt;&gt;.[bisequenceValidated](../bisequence-validated.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../bisequence-validated.md)&gt;): [Validated](../-validated/index.md)&lt;[A](../bisequence-validated.md), [Ior](index.md)&lt;[B](../bisequence-validated.md), [C](../bisequence-validated.md)&gt;&gt; |
| [combine](../combine.md) | [common]<br>fun &lt;[A](../combine.md), [B](../combine.md)&gt; [Ior](index.md)&lt;[A](../combine.md), [B](../combine.md)&gt;.[combine](../combine.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../combine.md)&gt;, SB: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[B](../combine.md)&gt;, other: [Ior](index.md)&lt;[A](../combine.md), [B](../combine.md)&gt;): [Ior](index.md)&lt;[A](../combine.md), [B](../combine.md)&gt; |
| [compareTo](../compare-to.md) | [common]<br>operator fun &lt;[A](../compare-to.md) : [Comparable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html)&lt;[A](../compare-to.md)&gt;, [B](../compare-to.md) : [Comparable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html)&lt;[B](../compare-to.md)&gt;&gt; [Ior](index.md)&lt;[A](../compare-to.md), [B](../compare-to.md)&gt;.[compareTo](../compare-to.md)(other: [Ior](index.md)&lt;[A](../compare-to.md), [B](../compare-to.md)&gt;): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
| [flatMap](../flat-map.md) | [common]<br>inline fun &lt;[A](../flat-map.md), [B](../flat-map.md), [D](../flat-map.md)&gt; [Ior](index.md)&lt;[A](../flat-map.md), [B](../flat-map.md)&gt;.[flatMap](../flat-map.md)(SG: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../flat-map.md)&gt;, f: ([B](../flat-map.md)) -&gt; [Ior](index.md)&lt;[A](../flat-map.md), [D](../flat-map.md)&gt;): [Ior](index.md)&lt;[A](../flat-map.md), [D](../flat-map.md)&gt;<br>Binds the given function across [Ior.Right](-right/index.md). |
| [flatten](../flatten.md) | [common]<br>inline fun &lt;[A](../flatten.md), [B](../flatten.md)&gt; [Ior](index.md)&lt;[A](../flatten.md), [Ior](index.md)&lt;[A](../flatten.md), [B](../flatten.md)&gt;&gt;.[flatten](../flatten.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../flatten.md)&gt;): [Ior](index.md)&lt;[A](../flatten.md), [B](../flatten.md)&gt; |
| [getOrElse](../get-or-else.md) | [common]<br>inline fun &lt;[A](../get-or-else.md), [B](../get-or-else.md)&gt; [Ior](index.md)&lt;[A](../get-or-else.md), [B](../get-or-else.md)&gt;.[getOrElse](../get-or-else.md)(default: () -&gt; [B](../get-or-else.md)): [B](../get-or-else.md) |
| [leftWiden](../left-widen.md) | [common]<br>fun &lt;[AA](../left-widen.md), [A](../left-widen.md) : [AA](../left-widen.md), [B](../left-widen.md)&gt; [Ior](index.md)&lt;[A](../left-widen.md), [B](../left-widen.md)&gt;.[leftWiden](../left-widen.md)(): [Ior](index.md)&lt;[AA](../left-widen.md), [B](../left-widen.md)&gt; |
| [replicate](../replicate.md) | [common]<br>fun &lt;[A](../replicate.md), [B](../replicate.md)&gt; [Ior](index.md)&lt;[A](../replicate.md), [B](../replicate.md)&gt;.[replicate](../replicate.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../replicate.md)&gt;, n: [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)): [Ior](index.md)&lt;[A](../replicate.md), [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[B](../replicate.md)&gt;&gt;<br>fun &lt;[A](../replicate.md), [B](../replicate.md)&gt; [Ior](index.md)&lt;[A](../replicate.md), [B](../replicate.md)&gt;.[replicate](../replicate.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../replicate.md)&gt;, n: [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html), MB: [Monoid](../../arrow.typeclasses/-monoid/index.md)&lt;[B](../replicate.md)&gt;): [Ior](index.md)&lt;[A](../replicate.md), [B](../replicate.md)&gt; |
| [sequence](../sequence.md) | [common]<br>fun &lt;[A](../sequence.md), [B](../sequence.md)&gt; [Ior](index.md)&lt;[A](../sequence.md), [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/index.html)&lt;[B](../sequence.md)&gt;&gt;.[sequence](../sequence.md)(): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[Ior](index.md)&lt;[A](../sequence.md), [B](../sequence.md)&gt;&gt; |
| [sequenceEither](../sequence-either.md) | [common]<br>fun &lt;[A](../sequence-either.md), [B](../sequence-either.md), [C](../sequence-either.md)&gt; [Ior](index.md)&lt;[A](../sequence-either.md), [Either](../-either/index.md)&lt;[B](../sequence-either.md), [C](../sequence-either.md)&gt;&gt;.[sequenceEither](../sequence-either.md)(): [Either](../-either/index.md)&lt;[B](../sequence-either.md), [Ior](index.md)&lt;[A](../sequence-either.md), [C](../sequence-either.md)&gt;&gt; |
| [sequenceNullable](../sequence-nullable.md) | [common]<br>fun &lt;[A](../sequence-nullable.md), [B](../sequence-nullable.md)&gt; [Ior](index.md)&lt;[A](../sequence-nullable.md), [B](../sequence-nullable.md)?&gt;.[sequenceNullable](../sequence-nullable.md)(): [Ior](index.md)&lt;[A](../sequence-nullable.md), [B](../sequence-nullable.md)&gt;? |
| [sequenceOption](../sequence-option.md) | [common]<br>fun &lt;[A](../sequence-option.md), [B](../sequence-option.md)&gt; [Ior](index.md)&lt;[A](../sequence-option.md), [Option](../-option/index.md)&lt;[B](../sequence-option.md)&gt;&gt;.[sequenceOption](../sequence-option.md)(): [Option](../-option/index.md)&lt;[Ior](index.md)&lt;[A](../sequence-option.md), [B](../sequence-option.md)&gt;&gt; |
| [sequenceValidated](../sequence-validated.md) | [common]<br>fun &lt;[A](../sequence-validated.md), [B](../sequence-validated.md), [C](../sequence-validated.md)&gt; [Ior](index.md)&lt;[A](../sequence-validated.md), [Validated](../-validated/index.md)&lt;[B](../sequence-validated.md), [C](../sequence-validated.md)&gt;&gt;.[sequenceValidated](../sequence-validated.md)(): [Validated](../-validated/index.md)&lt;[B](../sequence-validated.md), [Ior](index.md)&lt;[A](../sequence-validated.md), [C](../sequence-validated.md)&gt;&gt; |
| [widen](../widen.md) | [common]<br>fun &lt;[A](../widen.md), [C](../widen.md), [B](../widen.md) : [C](../widen.md)&gt; [Ior](index.md)&lt;[A](../widen.md), [B](../widen.md)&gt;.[widen](../widen.md)(): [Ior](index.md)&lt;[A](../widen.md), [C](../widen.md)&gt;<br>Given [B](../widen.md) is a sub type of [C](../widen.md), re-type this value from Ior to Ior |
| [zip](../zip.md) | [common]<br>fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, fb: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;): [Ior](index.md)&lt;[A](../zip.md), [Pair](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/index.html)&lt;[B](../zip.md), [C](../zip.md)&gt;&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md)) -&gt; [D](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, d: [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md), [D](../zip.md)) -&gt; [E](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [E](../zip.md)&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, d: [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;, e: [Ior](index.md)&lt;[A](../zip.md), [E](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md)) -&gt; [F](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [F](../zip.md)&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, d: [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;, e: [Ior](index.md)&lt;[A](../zip.md), [E](../zip.md)&gt;, f: [Ior](index.md)&lt;[A](../zip.md), [F](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md)) -&gt; [G](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [G](../zip.md)&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, d: [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;, e: [Ior](index.md)&lt;[A](../zip.md), [E](../zip.md)&gt;, f: [Ior](index.md)&lt;[A](../zip.md), [F](../zip.md)&gt;, g: [Ior](index.md)&lt;[A](../zip.md), [G](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md)) -&gt; [H](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [H](../zip.md)&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md), [I](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, d: [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;, e: [Ior](index.md)&lt;[A](../zip.md), [E](../zip.md)&gt;, f: [Ior](index.md)&lt;[A](../zip.md), [F](../zip.md)&gt;, g: [Ior](index.md)&lt;[A](../zip.md), [G](../zip.md)&gt;, h: [Ior](index.md)&lt;[A](../zip.md), [H](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md)) -&gt; [I](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [I](../zip.md)&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md), [I](../zip.md), [J](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, d: [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;, e: [Ior](index.md)&lt;[A](../zip.md), [E](../zip.md)&gt;, f: [Ior](index.md)&lt;[A](../zip.md), [F](../zip.md)&gt;, g: [Ior](index.md)&lt;[A](../zip.md), [G](../zip.md)&gt;, h: [Ior](index.md)&lt;[A](../zip.md), [H](../zip.md)&gt;, i: [Ior](index.md)&lt;[A](../zip.md), [I](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md), [I](../zip.md)) -&gt; [J](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [J](../zip.md)&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md), [I](../zip.md), [J](../zip.md), [K](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, d: [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;, e: [Ior](index.md)&lt;[A](../zip.md), [E](../zip.md)&gt;, f: [Ior](index.md)&lt;[A](../zip.md), [F](../zip.md)&gt;, g: [Ior](index.md)&lt;[A](../zip.md), [G](../zip.md)&gt;, h: [Ior](index.md)&lt;[A](../zip.md), [H](../zip.md)&gt;, i: [Ior](index.md)&lt;[A](../zip.md), [I](../zip.md)&gt;, j: [Ior](index.md)&lt;[A](../zip.md), [J](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md), [I](../zip.md), [J](../zip.md)) -&gt; [K](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [K](../zip.md)&gt;<br>inline fun &lt;[A](../zip.md), [B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md), [I](../zip.md), [J](../zip.md), [K](../zip.md), [L](../zip.md)&gt; [Ior](index.md)&lt;[A](../zip.md), [B](../zip.md)&gt;.[zip](../zip.md)(SA: [Semigroup](../../arrow.typeclasses/-semigroup/index.md)&lt;[A](../zip.md)&gt;, c: [Ior](index.md)&lt;[A](../zip.md), [C](../zip.md)&gt;, d: [Ior](index.md)&lt;[A](../zip.md), [D](../zip.md)&gt;, e: [Ior](index.md)&lt;[A](../zip.md), [E](../zip.md)&gt;, f: [Ior](index.md)&lt;[A](../zip.md), [F](../zip.md)&gt;, g: [Ior](index.md)&lt;[A](../zip.md), [G](../zip.md)&gt;, h: [Ior](index.md)&lt;[A](../zip.md), [H](../zip.md)&gt;, i: [Ior](index.md)&lt;[A](../zip.md), [I](../zip.md)&gt;, j: [Ior](index.md)&lt;[A](../zip.md), [J](../zip.md)&gt;, k: [Ior](index.md)&lt;[A](../zip.md), [K](../zip.md)&gt;, map: ([B](../zip.md), [C](../zip.md), [D](../zip.md), [E](../zip.md), [F](../zip.md), [G](../zip.md), [H](../zip.md), [I](../zip.md), [J](../zip.md), [K](../zip.md)) -&gt; [L](../zip.md)): [Ior](index.md)&lt;[A](../zip.md), [L](../zip.md)&gt; |
