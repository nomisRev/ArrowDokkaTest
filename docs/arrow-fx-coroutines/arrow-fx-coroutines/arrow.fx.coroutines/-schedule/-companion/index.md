//[arrow-fx-coroutines](../../../../index.md)/[arrow.fx.coroutines](../../index.md)/[Schedule](../index.md)/[Companion](index.md)

# Companion

[common]\
object [Companion](index.md)

## Functions

| Name | Summary |
|---|---|
| [collect](collect.md) | [common]<br>fun &lt;[A](collect.md)&gt; [collect](collect.md)(): [Schedule](../index.md)&lt;[A](collect.md), [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[A](collect.md)&gt;&gt;<br>Creates a Schedule which collects all its inputs in a list. |
| [decision](decision.md) | [common]<br>fun &lt;[A](decision.md)&gt; [decision](decision.md)(): [Schedule](../index.md)&lt;[A](decision.md), [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)&gt;<br>Creates a Schedule that returns its decisions. |
| [delayed](delayed.md) | [common]<br>@[JvmName](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index.html)(name = "delayedNanos")<br>fun &lt;[A](delayed.md)&gt; [delayed](delayed.md)(delaySchedule: [Schedule](../index.md)&lt;[A](delayed.md), [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)&gt;): [Schedule](../index.md)&lt;[A](delayed.md), [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)&gt;<br>@[ExperimentalTime](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-experimental-time/index.html)<br>@[JvmName](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index.html)(name = "delayedDuration")<br>fun &lt;[A](delayed.md)&gt; [delayed](delayed.md)(delaySchedule: [Schedule](../index.md)&lt;[A](delayed.md), [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)&gt;): [Schedule](../index.md)&lt;[A](delayed.md), [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)&gt;<br>Creates a Schedule that uses another Schedule to generate the delay of this schedule. Continues for as long as [delaySchedule](delayed.md) continues and adds the output of [delaySchedule](delayed.md) to the delay that [delaySchedule](delayed.md) produced. Also returns the full delay as output. |
| [delayInNanos](delay-in-nanos.md) | [common]<br>fun &lt;[A](delay-in-nanos.md)&gt; [delayInNanos](delay-in-nanos.md)(): [Schedule](../index.md)&lt;[A](delay-in-nanos.md), [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)&gt; |
| [doUntil](do-until.md) | [common]<br>fun &lt;[A](do-until.md)&gt; [doUntil](do-until.md)(f: suspend ([A](do-until.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [Schedule](../index.md)&lt;[A](do-until.md), [A](do-until.md)&gt;<br>Creates a Schedule that continues until [f](do-until.md) returns true. |
| [doWhile](do-while.md) | [common]<br>fun &lt;[A](do-while.md)&gt; [doWhile](do-while.md)(f: suspend ([A](do-while.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [Schedule](../index.md)&lt;[A](do-while.md), [A](do-while.md)&gt;<br>Creates a Schedule that continues as long as [f](do-while.md) returns true. |
| [duration](duration.md) | [common]<br>@[ExperimentalTime](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-experimental-time/index.html)<br>fun &lt;[A](duration.md)&gt; [duration](duration.md)(): [Schedule](../index.md)&lt;[A](duration.md), [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)&gt; |
| [exponential](exponential.md) | [common]<br>fun &lt;[A](exponential.md)&gt; [exponential](exponential.md)(base: [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html), factor: [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html) = 2.0): [Schedule](../index.md)&lt;[A](exponential.md), [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)&gt;<br>@[ExperimentalTime](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-experimental-time/index.html)<br>fun &lt;[A](exponential.md)&gt; [exponential](exponential.md)(base: [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html), factor: [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html) = 2.0): [Schedule](../index.md)&lt;[A](exponential.md), [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)&gt;<br>Creates a Schedule that increases its delay exponentially with a given factor and base. Delays can be calculated as [base](exponential.md) * factor ^ n where n is the number of executions. |
| [fibonacci](fibonacci.md) | [common]<br>fun &lt;[A](fibonacci.md)&gt; [fibonacci](fibonacci.md)(one: [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)): [Schedule](../index.md)&lt;[A](fibonacci.md), [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)&gt;<br>@[ExperimentalTime](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-experimental-time/index.html)<br>fun &lt;[A](fibonacci.md)&gt; [fibonacci](fibonacci.md)(one: [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)): [Schedule](../index.md)&lt;[A](fibonacci.md), [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)&gt;<br>Creates a Schedule that continues with increasing delay by adding the last two delays. |
| [forever](forever.md) | [common]<br>fun &lt;[A](forever.md)&gt; [forever](forever.md)(): [Schedule](../index.md)&lt;[A](forever.md), [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)&gt;<br>Creates a Schedule that continues forever and returns the number of iterations. |
| [identity](identity.md) | [common]<br>fun &lt;[A](identity.md)&gt; [identity](identity.md)(): [Schedule](../index.md)&lt;[A](identity.md), [A](identity.md)&gt;<br>Creates a Schedule that continues without delay and just returns its input. |
| [invoke](invoke.md) | [common]<br>operator fun &lt;[S](invoke.md), [A](invoke.md), [B](invoke.md)&gt; [invoke](invoke.md)(initial: suspend () -&gt; [S](invoke.md), update: suspend ([A](invoke.md), [S](invoke.md)) -&gt; [Schedule.Decision](../-decision/index.md)&lt;[S](invoke.md), [B](invoke.md)&gt;): [Schedule](../index.md)&lt;[A](invoke.md), [B](invoke.md)&gt;<br>Invoke constructor to manually define a schedule. If you need this, please consider adding it to Arrow or suggest a change to avoid using this manual method. |
| [linear](linear.md) | [common]<br>fun &lt;[A](linear.md)&gt; [linear](linear.md)(base: [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)): [Schedule](../index.md)&lt;[A](linear.md), [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)&gt;<br>@[ExperimentalTime](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-experimental-time/index.html)<br>fun &lt;[A](linear.md)&gt; [linear](linear.md)(base: [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)): [Schedule](../index.md)&lt;[A](linear.md), [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)&gt;<br>Creates a Schedule which increases its delay linearly, by n * base where n is the number of executions. |
| [logInput](log-input.md) | [common]<br>fun &lt;[A](log-input.md)&gt; [logInput](log-input.md)(f: suspend ([A](log-input.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)): [Schedule](../index.md)&lt;[A](log-input.md), [A](log-input.md)&gt;<br>Creates a Schedule with an effectful handler on the input. |
| [logOutput](log-output.md) | [common]<br>fun &lt;[A](log-output.md)&gt; [logOutput](log-output.md)(f: suspend ([A](log-output.md)) -&gt; [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)): [Schedule](../index.md)&lt;[A](log-output.md), [A](log-output.md)&gt;<br>Creates a Schedule with an effectful handler on the output. |
| [never](never.md) | [common]<br>fun &lt;[A](never.md)&gt; [never](never.md)(): [Schedule](../index.md)&lt;[A](never.md), [Nothing](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing/index.html)&gt;<br>Creates a schedule that never retries. |
| [once](once.md) | [common]<br>fun &lt;[A](once.md)&gt; [once](once.md)(): [Schedule](../index.md)&lt;[A](once.md), [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)&gt;<br>Creates a Schedule that only retries once. |
| [recurs](recurs.md) | [common]<br>fun &lt;[A](recurs.md)&gt; [recurs](recurs.md)(n: [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)): [Schedule](../index.md)&lt;[A](recurs.md), [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)&gt;<br>Creates a Schedule that continues n times and returns the number of iterations. |
| [spaced](spaced.md) | [common]<br>fun &lt;[A](spaced.md)&gt; [spaced](spaced.md)(interval: [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)): [Schedule](../index.md)&lt;[A](spaced.md), [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)&gt;<br>@[ExperimentalTime](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-experimental-time/index.html)<br>fun &lt;[A](spaced.md)&gt; [spaced](spaced.md)(interval: [Duration](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html)): [Schedule](../index.md)&lt;[A](spaced.md), [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)&gt;<br>Creates a Schedule that continues with a fixed delay. |
| [unfold](unfold.md) | [common]<br>fun &lt;[I](unfold.md), [A](unfold.md)&gt; [unfold](unfold.md)(c: [A](unfold.md), f: ([A](unfold.md)) -&gt; [A](unfold.md)): [Schedule](../index.md)&lt;[I](unfold.md), [A](unfold.md)&gt;<br>Non-effectful variant of [unfoldLazy](unfold-lazy.md) |
| [unfoldLazy](unfold-lazy.md) | [common]<br>fun &lt;[I](unfold-lazy.md), [A](unfold-lazy.md)&gt; [unfoldLazy](unfold-lazy.md)(c: suspend () -&gt; [A](unfold-lazy.md), f: suspend ([A](unfold-lazy.md)) -&gt; [A](unfold-lazy.md)): [Schedule](../index.md)&lt;[I](unfold-lazy.md), [A](unfold-lazy.md)&gt;<br>Creates a schedule that unfolds effectfully using a seed value [c](unfold-lazy.md) and a unfold function [f](unfold-lazy.md). This keeps the current state (the current seed) as State and runs the unfold function on every call to update. This schedule always continues without delay and returns the current state. |
| [unit](unit.md) | [common]<br>fun &lt;[A](unit.md)&gt; [unit](unit.md)(): [Schedule](../index.md)&lt;[A](unit.md), [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)&gt;<br>Creates a Schedule that continues without delay and always returns Unit. |
