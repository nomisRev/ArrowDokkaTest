//[arrow-optics](../../../index.md)/[arrow.optics](../index.md)/[PEvery](index.md)

# PEvery

[common]\
interface [PEvery](index.md)&lt;[S](index.md), [T](index.md), [A](index.md), [B](index.md)&gt; : [PTraversal](../-p-traversal/index.md)&lt;[S](index.md), [T](index.md), [A](index.md), [B](index.md)&gt; , [Fold](../-fold/index.md)&lt;[S](index.md), [A](index.md)&gt; , [PSetter](../-p-setter/index.md)&lt;[S](index.md), [T](index.md), [A](index.md), [B](index.md)&gt; 

Composition of Fold and Traversal It combines their powers

## Types

| Name | Summary |
|---|---|
| [Companion](-companion/index.md) | [common]<br>object [Companion](-companion/index.md) |

## Functions

| Name | Summary |
|---|---|
| [all](../-fold/all.md) | [common]<br>open fun [all](../-fold/all.md)(source: [S](index.md), predicate: ([A](index.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if all targets satisfy the predicate |
| [any](../-fold/any.md) | [common]<br>open fun [any](../-fold/any.md)(source: [S](index.md), predicate: ([A](index.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if at least one focus matches the given [predicate](../-fold/any.md). |
| [choice](../-fold/choice.md) | [common]<br>open infix fun &lt;[C](../-fold/choice.md)&gt; [choice](../-fold/choice.md)(other: [Fold](../-fold/index.md)&lt;[C](../-fold/choice.md), [A](index.md)&gt;): [Fold](../-fold/index.md)&lt;[Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[S](index.md), [C](../-fold/choice.md)&gt;, [A](index.md)&gt;<br>Join two [Fold](../-fold/index.md) with the same target<br>[common]<br>open infix fun &lt;[U](../-p-setter/choice.md), [V](../-p-setter/choice.md)&gt; [choice](../-p-setter/choice.md)(other: [PSetter](../-p-setter/index.md)&lt;[U](../-p-setter/choice.md), [V](../-p-setter/choice.md), [A](index.md), [B](index.md)&gt;): [PSetter](../-p-setter/index.md)&lt;[Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[S](index.md), [U](../-p-setter/choice.md)&gt;, [Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[T](index.md), [V](../-p-setter/choice.md)&gt;, [A](index.md), [B](index.md)&gt;<br>Join two [PSetter](../-p-setter/index.md) with the same target<br>[common]<br>open fun &lt;[U](../-p-traversal/choice.md), [V](../-p-traversal/choice.md)&gt; [choice](../-p-traversal/choice.md)(other: [PTraversal](../-p-traversal/index.md)&lt;[U](../-p-traversal/choice.md), [V](../-p-traversal/choice.md), [A](index.md), [B](index.md)&gt;): [PTraversal](../-p-traversal/index.md)&lt;[Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[S](index.md), [U](../-p-traversal/choice.md)&gt;, [Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[T](index.md), [V](../-p-traversal/choice.md)&gt;, [A](index.md), [B](index.md)&gt; |
| [combineAll](../-fold/combine-all.md) | [common]<br>open fun [combineAll](../-fold/combine-all.md)(M: [Monoid](../../../../arrow-core/arrow-core/arrow.typeclasses/-monoid/index.md)&lt;[A](index.md)&gt;, source: [S](index.md)): [A](index.md)<br>Alias for fold. |
| [compose](../-fold/compose.md) | [common]<br>open infix fun &lt;[C](../-fold/compose.md)&gt; [compose](../-fold/compose.md)(other: [Fold](../-fold/index.md)&lt;in [A](index.md), out [C](../-fold/compose.md)&gt;): [Fold](../-fold/index.md)&lt;[S](index.md), [C](../-fold/compose.md)&gt;<br>Compose a [Fold](../-fold/index.md) with a [Fold](../-fold/index.md)<br>[common]<br>open infix fun &lt;[C](compose.md), [D](compose.md)&gt; [compose](compose.md)(other: [PEvery](index.md)&lt;in [A](index.md), out [B](index.md), out [C](compose.md), in [D](compose.md)&gt;): [PEvery](index.md)&lt;[S](index.md), [T](index.md), [C](compose.md), [D](compose.md)&gt;<br>Compose a [PEvery](index.md) with a [PEvery](index.md)<br>[common]<br>open infix fun &lt;[C](../-p-setter/compose.md), [D](../-p-setter/compose.md)&gt; [compose](../-p-setter/compose.md)(other: [PSetter](../-p-setter/index.md)&lt;in [A](index.md), out [B](index.md), out [C](../-p-setter/compose.md), in [D](../-p-setter/compose.md)&gt;): [PSetter](../-p-setter/index.md)&lt;[S](index.md), [T](index.md), [C](../-p-setter/compose.md), [D](../-p-setter/compose.md)&gt;<br>Compose a [PSetter](../-p-setter/index.md) with a [PSetter](../-p-setter/index.md)<br>[common]<br>open infix fun &lt;[C](../-p-traversal/compose.md), [D](../-p-traversal/compose.md)&gt; [compose](../-p-traversal/compose.md)(other: [PTraversal](../-p-traversal/index.md)&lt;in [A](index.md), out [B](index.md), out [C](../-p-traversal/compose.md), in [D](../-p-traversal/compose.md)&gt;): [PTraversal](../-p-traversal/index.md)&lt;[S](index.md), [T](index.md), [C](../-p-traversal/compose.md), [D](../-p-traversal/compose.md)&gt;<br>Compose a [PTraversal](../-p-traversal/index.md) with a [PTraversal](../-p-traversal/index.md) |
| [exists](../-fold/exists.md) | [common]<br>open fun [exists](../-fold/exists.md)(source: [S](index.md), predicate: ([A](index.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check whether at least one element satisfies the predicate. |
| [findOrNull](../-fold/find-or-null.md) | [common]<br>open fun [findOrNull](../-fold/find-or-null.md)(source: [S](index.md), predicate: ([A](index.md)) -&gt; [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)): [A](index.md)?<br>Find the first element matching the predicate, if one exists. |
| [firstOrNull](../-fold/first-or-null.md) | [common]<br>open fun [firstOrNull](../-fold/first-or-null.md)(source: [S](index.md)): [A](index.md)?<br>Get the first target or null |
| [fold](../-fold/fold.md) | [common]<br>open fun [fold](../-fold/fold.md)(M: [Monoid](../../../../arrow-core/arrow-core/arrow.typeclasses/-monoid/index.md)&lt;[A](index.md)&gt;, source: [S](index.md)): [A](index.md)<br>Fold using the given [Monoid](../../../../arrow-core/arrow-core/arrow.typeclasses/-monoid/index.md) instance. |
| [foldMap](fold-map.md) | [common]<br>abstract override fun &lt;[R](fold-map.md)&gt; [foldMap](fold-map.md)(M: [Monoid](../../../../arrow-core/arrow-core/arrow.typeclasses/-monoid/index.md)&lt;[R](fold-map.md)&gt;, source: [S](index.md), map: ([A](index.md)) -&gt; [R](fold-map.md)): [R](fold-map.md)<br>Map each target to a type R and use a Monoid to fold the results |
| [getAll](../-fold/get-all.md) | [common]<br>open fun [getAll](../-fold/get-all.md)(source: [S](index.md)): [List](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)&lt;[A](index.md)&gt;<br>Get all targets of the [Fold](../-fold/index.md) |
| [isEmpty](../-fold/is-empty.md) | [common]<br>open fun [isEmpty](../-fold/is-empty.md)(source: [S](index.md)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is no target |
| [isNotEmpty](../-fold/is-not-empty.md) | [common]<br>open fun [isNotEmpty](../-fold/is-not-empty.md)(source: [S](index.md)): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is at least one target |
| [lastOrNull](../-fold/last-or-null.md) | [common]<br>open fun [lastOrNull](../-fold/last-or-null.md)(source: [S](index.md)): [A](index.md)?<br>Get the last target or null |
| [left](../-fold/left.md) | [common]<br>open fun &lt;[C](../-fold/left.md)&gt; [left](../-fold/left.md)(): [Fold](../-fold/index.md)&lt;[Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[S](index.md), [C](../-fold/left.md)&gt;, [Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[A](index.md), [C](../-fold/left.md)&gt;&gt;<br>Create a sum of the [Fold](../-fold/index.md) and a type [C](../-fold/left.md) |
| [lift](../-p-setter/lift.md) | [common]<br>open fun [lift](../-p-setter/lift.md)(map: ([A](index.md)) -&gt; [B](index.md)): ([S](index.md)) -&gt; [T](index.md)<br>Lift a function [map](../-p-setter/lift.md): (A) -&gt; B to the context of S: (S) -> T` |
| [modify](modify.md) | [common]<br>abstract override fun [modify](modify.md)(source: [S](index.md), map: ([A](index.md)) -&gt; [B](index.md)): [T](index.md)<br>Modify polymorphically the focus of a [PSetter](../-p-setter/index.md) with a function [map](modify.md). |
| [plus](../-fold/plus.md) | [common]<br>open operator fun &lt;[C](../-fold/plus.md)&gt; [plus](../-fold/plus.md)(other: [Fold](../-fold/index.md)&lt;in [A](index.md), out [C](../-fold/plus.md)&gt;): [Fold](../-fold/index.md)&lt;[S](index.md), [C](../-fold/plus.md)&gt;<br>open operator fun &lt;[C](plus.md), [D](plus.md)&gt; [plus](plus.md)(other: [PEvery](index.md)&lt;in [A](index.md), out [B](index.md), out [C](plus.md), in [D](plus.md)&gt;): [PEvery](index.md)&lt;[S](index.md), [T](index.md), [C](plus.md), [D](plus.md)&gt;<br>open operator fun &lt;[C](../-p-setter/plus.md), [D](../-p-setter/plus.md)&gt; [plus](../-p-setter/plus.md)(other: [PSetter](../-p-setter/index.md)&lt;in [A](index.md), out [B](index.md), out [C](../-p-setter/plus.md), in [D](../-p-setter/plus.md)&gt;): [PSetter](../-p-setter/index.md)&lt;[S](index.md), [T](index.md), [C](../-p-setter/plus.md), [D](../-p-setter/plus.md)&gt;<br>open operator fun &lt;[C](../-p-traversal/plus.md), [D](../-p-traversal/plus.md)&gt; [plus](../-p-traversal/plus.md)(other: [PTraversal](../-p-traversal/index.md)&lt;in [A](index.md), out [B](index.md), out [C](../-p-traversal/plus.md), in [D](../-p-traversal/plus.md)&gt;): [PTraversal](../-p-traversal/index.md)&lt;[S](index.md), [T](index.md), [C](../-p-traversal/plus.md), [D](../-p-traversal/plus.md)&gt; |
| [right](../-fold/right.md) | [common]<br>open fun &lt;[C](../-fold/right.md)&gt; [right](../-fold/right.md)(): [Fold](../-fold/index.md)&lt;[Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[C](../-fold/right.md), [S](index.md)&gt;, [Either](../../../../arrow-core/arrow-core/arrow.core/-either/index.md)&lt;[C](../-fold/right.md), [A](index.md)&gt;&gt;<br>Create a sum of a type [C](../-fold/right.md) and the [Fold](../-fold/index.md) |
| [set](../-p-setter/set.md) | [common]<br>open fun [set](../-p-setter/set.md)(source: [S](index.md), focus: [B](index.md)): [T](index.md)<br>Set polymorphically the focus of a [PSetter](../-p-setter/index.md) with a value b. |
| [size](../-fold/size.md) | [common]<br>open fun [size](../-fold/size.md)(source: [S](index.md)): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Calculate the number of targets |

## Properties

| Name | Summary |
|---|---|
| [every](every.md) | [common]<br>open override val &lt;[U](every.md), [V](every.md)&gt; [PLens](../-p-lens/index.md)&lt;[U](every.md), [V](every.md), [S](index.md), [T](index.md)&gt;.[every](every.md): [PEvery](index.md)&lt;[U](every.md), [V](every.md), [A](index.md), [B](index.md)&gt;<br>DSL to compose [Every](../index.md#176863642%2FClasslikes%2F-617900156) with a [Lens](../index.md#-141055921%2FClasslikes%2F-617900156) for a structure [S](index.md) to see all its foci [A](index.md) |
| [every](every.md) | [common]<br>open override val &lt;[U](every.md), [V](every.md)&gt; [PIso](../-p-iso/index.md)&lt;[U](every.md), [V](every.md), [S](index.md), [T](index.md)&gt;.[every](every.md): [PEvery](index.md)&lt;[U](every.md), [V](every.md), [A](index.md), [B](index.md)&gt;<br>DSL to compose [Every](../index.md#176863642%2FClasslikes%2F-617900156) with a [Iso](../index.md#1786632304%2FClasslikes%2F-617900156) for a structure [S](index.md) to see all its foci [A](index.md) |
| [every](every.md) | [common]<br>open override val &lt;[U](every.md), [V](every.md)&gt; [PPrism](../-p-prism/index.md)&lt;[U](every.md), [V](every.md), [S](index.md), [T](index.md)&gt;.[every](every.md): [PEvery](index.md)&lt;[U](every.md), [V](every.md), [A](index.md), [B](index.md)&gt;<br>DSL to compose [Every](../index.md#176863642%2FClasslikes%2F-617900156) with a [Prism](../index.md#1394331700%2FClasslikes%2F-617900156) for a structure [S](index.md) to see all its foci [A](index.md) |
| [every](every.md) | [common]<br>open override val &lt;[U](every.md), [V](every.md)&gt; [POptional](../-p-optional/index.md)&lt;[U](every.md), [V](every.md), [S](index.md), [T](index.md)&gt;.[every](every.md): [PEvery](index.md)&lt;[U](every.md), [V](every.md), [A](index.md), [B](index.md)&gt;<br>DSL to compose [Every](../index.md#176863642%2FClasslikes%2F-617900156) with a [Optional](../index.md#-1955528147%2FClasslikes%2F-617900156) for a structure [S](index.md) to see all its foci [A](index.md) |
| [every](every.md) | [common]<br>open override val &lt;[U](every.md), [V](every.md)&gt; [PSetter](../-p-setter/index.md)&lt;[U](every.md), [V](every.md), [S](index.md), [T](index.md)&gt;.[every](every.md): [PSetter](../-p-setter/index.md)&lt;[U](every.md), [V](every.md), [A](index.md), [B](index.md)&gt;<br>DSL to compose [Every](../index.md#176863642%2FClasslikes%2F-617900156) with a [Setter](../index.md#744232174%2FClasslikes%2F-617900156) for a structure [S](index.md) to see all its foci [A](index.md) |
| [every](every.md) | [common]<br>open override val &lt;[U](every.md), [V](every.md)&gt; [PTraversal](../-p-traversal/index.md)&lt;[U](every.md), [V](every.md), [S](index.md), [T](index.md)&gt;.[every](every.md): [PTraversal](../-p-traversal/index.md)&lt;[U](every.md), [V](every.md), [A](index.md), [B](index.md)&gt;<br>DSL to compose [Every](../index.md#176863642%2FClasslikes%2F-617900156) with a [Traversal](../index.md#153853783%2FClasslikes%2F-617900156) for a structure [S](index.md) to see all its foci [A](index.md) |
| [every](../-p-traversal/every.md) | [common]<br>open val &lt;[U](../-p-traversal/every.md), [V](../-p-traversal/every.md)&gt; [PEvery](index.md)&lt;[U](../-p-traversal/every.md), [V](../-p-traversal/every.md), [S](index.md), [T](index.md)&gt;.[every](../-p-traversal/every.md): [PTraversal](../-p-traversal/index.md)&lt;[U](../-p-traversal/every.md), [V](../-p-traversal/every.md), [A](index.md), [B](index.md)&gt;<br>DSL to compose [Traversal](../index.md#153853783%2FClasslikes%2F-617900156) with a [PEvery](index.md) for a structure [S](../-p-traversal/index.md) to see all its foci [A](../-p-traversal/index.md) |

## Inheritors

| Name |
|---|
| [PIso](../-p-iso/index.md) |
| [PLens](../-p-lens/index.md) |
| [POptional](../-p-optional/index.md) |
| [PPrism](../-p-prism/index.md) |
